package org.extraktion.coverageanalyses;

import java.util.ArrayList;
import java.util.List;

import org.activiti.bpmn.model.BpmnModel;
import org.activiti.bpmn.model.Process;
import org.activiti.bpmn.model.SequenceFlow;
import org.activiti.engine.ProcessEngine;
import org.activiti.engine.ProcessEngineConfiguration;
import org.extraktion.TestObjectDesigner;
import org.hibernate.Session;
import org.hibernate.SessionFactory;

/**
 * Analyse auf Basis der Zweigueberdeckung.
 * 
 * @author Sascha Buelles
 *
 */
public class Coverage {

	private SessionFactory hibernateSessionFactory;
	private ProcessEngine processEngine;

	public Coverage() {
		this.initialize();
	}

	private void initialize() {
		hibernateSessionFactory = TestObjectDesigner.getInstance().getHibernateSessionFactory();
		processEngine = ProcessEngineConfiguration.createProcessEngineConfigurationFromResource("activiti.cfg.xml")
				.buildProcessEngine();

	}
	/**
	 * Anzahl der ausgefuehrten Sequenzfluesse in aktueller Extraktion.
	 * @return Double ausgefuehrten Sequenzfluesse
	 */
	private double getExecutedProcessSequenceFlows() {
		Session openSession = hibernateSessionFactory.openSession();
		double amountExecutedSequenceFlows = (double) openSession
				.createNativeQuery(
						"Select ELEMENTDEFINITIONKEY  FROM EXTRAKTION WHERE ELEMENTNAME ='SequenceFlowElement'")
				.getResultList().size();

		openSession.close();
		return amountExecutedSequenceFlows;

	}

	/**
	 * Anzahl aller Sequenzfluesse fur die in der Extraktionstabelle (startElement) angelegte ProzessID.
	 * @return Double alle Sequenzfluesse
	 */
	private double getExistingProcessSequenceFlows() {
		Session openSession = hibernateSessionFactory.openSession();
		List<BpmnModel> models = new ArrayList<BpmnModel>();

		@SuppressWarnings("unchecked")
		List<String> resultList = openSession
				.createNativeQuery("Select Prozesskey FROM EXTRAKTION WHERE ELEMENTNAME = 'StartElement'")
				.getResultList();
		for (String processkey : resultList) {
			models.add(processEngine.getRepositoryService().getBpmnModel(processkey));
		}

		int amountOfSequenceFlows = 0;
		for (BpmnModel model : models) {
			List<Process> processes = model.getProcesses();
			for (Process process : processes) {
				amountOfSequenceFlows += process.findFlowElementsOfType(SequenceFlow.class).size();

			}
		}

		return (double) amountOfSequenceFlows;
	}

	/**
	 * Sequenfflussanalyse, Pfadanalyse.
	 * 
	 * @return Double Kennzahl
	 */
	public double getPathCoverage() {
		double existingProcessSequenceFlows = this.getExistingProcessSequenceFlows();
		if (existingProcessSequenceFlows == 0) {
			return 0;
		}
		processEngine.close();
		return (getExecutedProcessSequenceFlows() / existingProcessSequenceFlows);
	}

}
