package org.extraktion.controlUI;

import java.util.List;

import org.extraktion.TestObjectDesigner;
import org.extraktion.coverageanalyses.Coverage;
import org.hibernate.Session;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javafx.application.Application;
import javafx.application.Platform;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.concurrent.Task;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.control.ListView;
import javafx.scene.control.TextField;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.GridPane;
import javafx.stage.Stage;
import javafx.stage.WindowEvent;

/**
 * User Interface zur Kontrolle der Extraktion.
 * 
 * @author Sascha Buelles
 */
public class RecordingControlWindow extends Application implements Runnable {
	/**
	 * Observierte Objekte der GUI.
	 */
	private ObservableList<String> data = FXCollections.observableArrayList();

	/**
	 * Logger des Kontrollinterfaces.
	 */
	private static Logger log = LoggerFactory.getLogger(RecordingControlWindow.class);

	/**
	 * Label für Kennzahlen einer Analyse.
	 */
	private static Label aktuelleuberdeckung;
	private static Label aktuelleUserTaskUeberdeckung;

	/**
	 * Breite des Applicaktionsfensters.
	 */
	private static final int HEIGHT = 400;
	/**
	 * Breite des Applicaktionsfensters.
	 */

	private static final int BUTTONWIDTH = 250;
	/**
	 * Intervall zwischen Abfragen an die Datenbank zum aktuellen Stand.
	 */
	private static final int WIDTH = 650;
	/**
	 * Intervall zwischen Abfragen an die Datenbank zum aktuellen Stand.
	 */
	private static final int QUERYTIME = 2000;

	private static Stage pStage = null;

	/**
	 * Standard Eintrittspunkt in JavaFX Applikation.
	 * 
	 * @param args
	 *            Standard Argumente
	 */
	public static void main(final String[] args) {
		RecordingControlWindow.launch(args);
	}

	@Override
	public final void start(final Stage primaryStage) {
		pStage = primaryStage;
		Thread thread = new Thread(aktualisiereAnsicht());
		thread.start();
		primaryStage.setTitle("Recording Control Panel");
		Button createTestfileButton = new Button();
		createTestfileButton.setPrefWidth(BUTTONWIDTH);
		createTestfileButton.setText("Create TestFile");
		Button clearButton = new Button();
		clearButton.setPrefWidth(BUTTONWIDTH);
		clearButton.setText("Clear System and Close");
		TextField jUnitTestClassName = new TextField();

		GridPane controlButtons = new GridPane();
		controlButtons.add(createTestfileButton, 0, 0);
		controlButtons.add(clearButton, 0, 1);

		ListView<String> lw = new ListView<String>();
		lw.setPrefWidth(WIDTH - BUTTONWIDTH);
		lw.setItems(data);

		BorderPane root = new BorderPane();
		root.setLeft(controlButtons);
		root.setTop(jUnitTestClassName);
		root.setBottom(getAnalysePane());
		root.setRight(lw);

		primaryStage.setScene(new Scene(root, WIDTH, HEIGHT));
		primaryStage.show();

		createTestfileButton.setOnAction(new EventHandler<ActionEvent>() {
			@Override
			public void handle(final ActionEvent event) {
				TestObjectDesigner.getInstance();
				TestObjectDesigner.getInstance().getHibernateSessionFactory();
				TestObjectDesigner.createJUnitTestContent(jUnitTestClassName.getText());
			}
		});
		clearButton.setOnAction(new EventHandler<ActionEvent>() {
			@Override
			public void handle(final ActionEvent event) {
				TestObjectDesigner.getInstance();
				Session openSession = TestObjectDesigner.getInstance().getHibernateSessionFactory().openSession();
				openSession.getTransaction().begin();
				try {
					openSession.createNativeQuery("DELETE FROM EXTRAKTION").executeUpdate();
					data.clear();
				} catch (Exception e) {
					log.error("Cleaning failed");
				}
				openSession.close();
				TestObjectDesigner.getInstance().clearAndClose();

			}
		});

	}

	/**
	 * @return Liefert GridPane reserviert für Analysekennzahlen
	 */
	private GridPane getAnalysePane() {
		GridPane gp = new GridPane();
		aktuelleuberdeckung = new Label("");
		aktuelleUserTaskUeberdeckung = new Label();
		Label zweigueberdeckung = new Label("C1 Zweigüberdeckung:");
		Label userTaskueberdeckung = new Label("C0 User Task Überdeckung:");

		gp.add(zweigueberdeckung, 0, 0);
		gp.add(aktuelleuberdeckung, 2, 0);
		gp.add(userTaskueberdeckung, 0, 1);
		gp.add(aktuelleUserTaskUeberdeckung, 2, 1);
		gp.setPrefWidth(WIDTH);
		return gp;
	}

	/**
	 * @param c2aktuell
	 *            Neuer Wert der Anaylse
	 */
	public static void aktualisiereUeberdeckungen(final String pathCoverage, final String userTaskCoverage) {
		Platform.runLater(new Runnable() {
			@Override
			public void run() {
				aktuelleuberdeckung.setText(pathCoverage);
				aktuelleUserTaskUeberdeckung.setText(userTaskCoverage);
			}
		});
	}

	/**
	 * @return Erstellt neuen Java Task, der alle 2 Sekunden den aktuellen Stand
	 *         aus der DB ließt.
	 */
	private Task<Integer> aktualisiereAnsicht() {
		Task<Integer> task = new Task<Integer>() {
			@SuppressWarnings("unchecked")
			@Override
			protected Integer call() throws Exception {
				while (true) {
					Platform.runLater(new Runnable() {
						@Override
						public void run() {
							Session openSession = TestObjectDesigner.getInstance().getHibernateSessionFactory()
									.openSession();
							List<String> resultList = openSession
									.createNativeQuery("select ELEMENTDEFINITIONKEY from EXTRAKTION").getResultList();

							data.clear();
							for (String string : resultList) {
								data.add(string);
							}
							openSession.close();
							Coverage cover = new Coverage();

							aktualisiereUeberdeckungen(Double.toString(cover.getPathCoverage()),(Double.toString(cover.getUserTaskCoverage())));
							
							
						}
					});
					try {
						Thread.sleep(QUERYTIME);
					} catch (InterruptedException interrupted) {
						if (isCancelled()) {
							updateMessage("Cancelled");
							break;
						}
					}
				}
				return 0;
			}
		};
		return task;
	}

	public static void close() {
		Platform.runLater(new Runnable() {
			@Override
			public void run() {
				pStage.fireEvent(new WindowEvent(pStage, WindowEvent.WINDOW_CLOSE_REQUEST));

			}
		});
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see java.lang.Runnable#run() unused
	 */
	@Override
	public void run() {
	}
}
