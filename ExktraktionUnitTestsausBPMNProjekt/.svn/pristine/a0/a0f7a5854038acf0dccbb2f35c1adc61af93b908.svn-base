package org.extraktion.controlUI;

import java.util.List;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

import org.extraktion.TestObjectDesigner;
import org.extraktion.coverageanalyses.Coverage;
import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javafx.application.Application;
import javafx.application.Platform;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.concurrent.Task;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.control.ListView;
import javafx.scene.control.TextField;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.GridPane;
import javafx.stage.Stage;
import javafx.stage.WindowEvent;

/**
 * User Interface zur Kontrolle der Extraktion.
 * 
 * @author Sascha Buelles
 */
public class RecordingControlWindow extends Application implements Runnable {
	/**
	 * Observierte Objekte der GUI.
	 */
	private static ObservableList<String> data = FXCollections.observableArrayList();

	volatile static boolean interrupted = false;

	/**
	 * Logger des Kontrollinterfaces.
	 */
	private static Logger log = LoggerFactory.getLogger(RecordingControlWindow.class);

	/**
	 * Label für Kennzahlen einer Analyse.
	 */
	private static Label aktuelleuberdeckung;
	private static Label aktuelleUserTaskUeberdeckung;

	/**
	 * Breite des Applicaktionsfensters.
	 */
	private static final int HEIGHT = 400;
	/**
	 * Breite des Applicaktionsfensters.
	 */

	private static final int BUTTONWIDTH = 250;
	/**
	 * Intervall zwischen Abfragen an die Datenbank zum aktuellen Stand.
	 */
	private static final int WIDTH = 650;
	/**
	 * Intervall zwischen Abfragen an die Datenbank zum aktuellen Stand.
	 */
	private static final int QUERYTIME = 2000;

	private static Stage pStage = null;

	/**
	 * Standard Eintrittspunkt in JavaFX Applikation.
	 * 
	 * @param args
	 *            Standard Argumente
	 */
	public static void main(final String[] args) {
		RecordingControlWindow.launch(args);
	}

	@Override
	public final void start(final Stage primaryStage) {
		pStage = primaryStage;

		primaryStage.setTitle("Recording Control Panel");

		Button createTestfileButton = new Button();
		createTestfileButton.setPrefWidth(BUTTONWIDTH);
		createTestfileButton.setText("Create TestFile");
		Button clearButton = new Button();
		clearButton.setPrefWidth(BUTTONWIDTH);
		clearButton.setText("Clear System and Close");
		TextField jUnitTestClassName = new TextField();
		Button getdata = new Button("Get Data");
		GridPane controlButtons = new GridPane();
		controlButtons.add(createTestfileButton, 0, 0);
		controlButtons.add(clearButton, 0, 1);
		controlButtons.add(getdata, 0, 1);

		ListView<String> lw = new ListView<String>();
		lw.setPrefWidth(WIDTH - BUTTONWIDTH);
		lw.setItems(data);

		BorderPane root = new BorderPane();
		root.setLeft(controlButtons);
		root.setTop(jUnitTestClassName);
		root.setBottom(getAnalysePane());
		root.setRight(lw);

		primaryStage.setScene(new Scene(root, WIDTH, HEIGHT));
		primaryStage.show();

		primaryStage.setOnCloseRequest(new EventHandler<WindowEvent>() {
			@Override
			public void handle(final WindowEvent event) {
				if (TestObjectDesigner.getInstance().getHibernateSessionFactory().isOpen()) {
					TestObjectDesigner.getInstance().getHibernateSessionFactory().close();
				}
				TestObjectDesigner.getInstance().closeSessionfactory();
				
			}
		});

		getdata.setOnAction(new EventHandler<ActionEvent>() {
			@Override
			public void handle(final ActionEvent event) {
				System.out.println("aktualisiere view");
				Platform.runLater(new Runnable() {
					@Override
					public void run() {
						Coverage cover = new Coverage();
						TestObjectDesigner.getInstance();
						SessionFactory hibernateSessionFactory = TestObjectDesigner.getInstance()
								.getHibernateSessionFactory();
						Session hibernateSession = hibernateSessionFactory.openSession();

						@SuppressWarnings("unchecked")
						List<String> resultList = hibernateSession
								.createNativeQuery("select ELEMENTDEFINITIONKEY from EXTRAKTION").getResultList();
						hibernateSession.beginTransaction().commit();
						data.clear();
						for (String string : resultList) {
							data.add(string);
						}
						aktualisiereUeberdeckungen(Double.toString(cover.getPathCoverage()),
								(Double.toString(cover.getUserTaskCoverage())));

						cover.closeContext();
						cover = null;

					}
				});

			}
		});

		createTestfileButton.setOnAction(new EventHandler<ActionEvent>() {

			@Override
			public void handle(final ActionEvent event) {
				TestObjectDesigner.getInstance();

				TestObjectDesigner.createJUnitTestContent(jUnitTestClassName.getText());
				TestObjectDesigner.getInstance().clearAndClose();

			}
		});
		clearButton.setOnAction(new EventHandler<ActionEvent>() {
			@Override
			public void handle(final ActionEvent event) {
				TestObjectDesigner.getInstance();
				SessionFactory hibernateSessionFactory = TestObjectDesigner.getInstance().getHibernateSessionFactory();
				Session openSession = hibernateSessionFactory.openSession();
				openSession.getTransaction().begin();
				try {
					openSession.createNativeQuery("DELETE FROM EXTRAKTION").executeUpdate();
					data.clear();
				} catch (Exception e) {
					log.error("Cleaning failed");
				}
				openSession.close();
				TestObjectDesigner.getInstance().clearAndClose();

			}
		});

	}

	/**
	 * @return Liefert GridPane reserviert für Analysekennzahlen
	 */
	private GridPane getAnalysePane() {
		GridPane gp = new GridPane();
		aktuelleuberdeckung = new Label("");
		aktuelleUserTaskUeberdeckung = new Label();
		Label zweigueberdeckung = new Label("C1 Zweigüberdeckung:");
		Label userTaskueberdeckung = new Label("C0 User Task Überdeckung:");

		gp.add(zweigueberdeckung, 0, 0);
		gp.add(aktuelleuberdeckung, 2, 0);
		gp.add(userTaskueberdeckung, 0, 1);
		gp.add(aktuelleUserTaskUeberdeckung, 2, 1);
		gp.setPrefWidth(WIDTH);
		return gp;
	}

	/**
	 * @param c2aktuell
	 *            Neuer Wert der Anaylse
	 */
	public static void aktualisiereUeberdeckungen(final String pathCoverage, final String userTaskCoverage) {

		aktuelleuberdeckung.setText(pathCoverage);
		aktuelleUserTaskUeberdeckung.setText(userTaskCoverage);

	}

	// /**
	// * @return Erstellt neuen Java Task, der alle 2 Sekunden den aktuellen
	// Stand
	// * aus der DB ließt.
	// */
	// private static Task<Integer> aktualisiereAnsicht() {
	// Task<Integer> task = new Task<Integer>() {
	// @SuppressWarnings("unchecked")
	// @Override
	// protected synchronized Integer call() throws Exception {
	//
	// return 0;
	// }
	//
	// };
	// return task;
	// }

	public static void close() {
		Platform.runLater(new Runnable() {
			@Override
			public void run() {
				pStage.fireEvent(new WindowEvent(pStage, WindowEvent.WINDOW_CLOSE_REQUEST));

			}
		});
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see java.lang.Runnable#run() unused
	 */
	@Override
	public void run() {
	}
}
